import yaml
import argparse

def generate_params_vh(yaml_path, hex_path, output_path):
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)

    with open(output_path, 'w') as vh:
        # write file header
        vh.write("// Auto-generated parameters header\n")
        vh.write("// DO NOT EDIT - Generated by paramsgen.py\n\n")

        # write hex file path
        vh.write(f"`define HEX_FILE \"{hex_path}\"\n")

        # process parameter macros
        if 'params' in data:
            vh.write("// Parameter macros\n")
            for key, value in data['params'].items():
                vh.write(f"`define {key} {value}\n")
            
            # add INSTRW related macros
            instrw = data['params'].get('INSTRW')
            if instrw == 32:
                vh.write("\n// Instruction width 32 bit\n")
                vh.write("`define INS_FUNC  5\n")
                vh.write("`define INS_RES   9\n")
                vh.write("`define INS_OP0   9\n")
                vh.write("`define INS_OP1   9\n")
                vh.write("`define IMSLICESZ 4096\n")
                vh.write("`define IMSLICEW  36\n")
                vh.write("`define DMSLICESZ 512\n")
                vh.write("`define DMSLICEW  64\n")
            elif instrw == 36:
                vh.write("\n// Instruction width 36 bit\n")
                vh.write("`define INS_FUNC  6\n")
                vh.write("`define INS_RES   10\n")
                vh.write("`define INS_OP0   10\n")
                vh.write("`define INS_OP1   10\n")
                vh.write("`define IMSLICESZ 8192\n")
                vh.write("`define IMSLICEW  36\n")
                vh.write("`define DMSLICESZ 1024\n")
                vh.write("`define DMSLICEW  36\n")



        # process const array
        if 'const' in data:
            const_items = sorted(data['const'].items(),
                               key=lambda x: int(x[0][1:]))
            const_num = len(const_items)
            vh.write("\n// Constant array\n")
            vh.write(f"`define CONST_NUM {const_num}\n")
            vh.write(f"wire [`WORDSZ-1:0] const_datas [0:{const_num-1}] = {{\n")
            entries = [f"`WORDSZ'h{item[1].split('h')[1]}" for item in const_items]
            vh.write(",\n".join([f"  {e}" for e in entries]) + "\n};\n")

        # count test items
        def count_test_items(d, mode):
            count = 0
            if isinstance(d, dict):
                if 'in' in d and mode == 'inputs':
                    count += len(d['in'])
                if 'out' in d and mode == 'outputs':
                    count += len(d['out'])
                for v in d.values():
                    count += count_test_items(v, mode)
            return count

        if 'testcase' in data:
            # generate test case item counts
            inputs_num = count_test_items(data['testcase'], 'inputs')
            outputs_num = count_test_items(data['testcase'], 'outputs')
            vh.write(f"\n`define TEST_INPUTS_NUM {inputs_num}\n")
            vh.write(f"`define TEST_OUTPUTS_NUM {outputs_num}\n")

            # collect test items
            def collect_items(d, mode, items):
                if isinstance(d, dict):
                    if mode in d:
                        sorted_items = sorted(d[mode].items(),
                                           key=lambda x: int(x[0][1:]))
                        items.extend([v for _, v in sorted_items])
                    for v in d.values():
                        collect_items(v, mode, items)

            # input items
            input_items = []
            collect_items(data['testcase'], 'in', input_items)
            vh.write("\n// Test inputs array\n")
            vh.write(f"wire [`WORDSZ-1:0] test_inputs [0:{inputs_num-1}] = {{\n")
            entries = [f"`WORDSZ'h{item.split('h')[1]}" for item in input_items]
            vh.write(",\n".join([f"  {e}" for e in entries]) + "\n};\n")

            # output items
            output_items = []
            collect_items(data['testcase'], 'out', output_items)
            if output_items:
                vh.write("\n// Test outputs array\n")
                vh.write(f"wire [`WORDSZ-1:0] test_outputs [0:{outputs_num-1}] = {{\n")
                entries = [f"`WORDSZ'h{item.split('h')[1]}" for item in output_items]
                vh.write(",\n".join([f"  {e}" for e in entries]) + "\n};\n")

if __name__ == "__main__":
    # create command line argument parser
    parser = argparse.ArgumentParser(
        description='Generate Verilog header from YAML parameters')
    
    # add input and output arguments
    parser.add_argument('-i', '--input',
                        required=True,
                        help='Input YAML configuration file path')
    
    
    parser.add_argument('-x', '--hexfile',
                        required=True,
                        help='Input the absolute path to the generated hex file; Note: The path must be absolute, e.g., /home/user/hexfile.hex; If you are windows user, please also use forward slash like C:/Users/user/hexfile.hex')

    parser.add_argument('-o', '--output',
                        default='../define/params.svh',
                        help='Output Verilog header file path (default: ../define/params.svh)')

    # analyze command line arguments
    args = parser.parse_args()

    # execute generation logic
    try:
        generate_params_vh(args.input, args.hexfile, args.output)
        print(f"Header file generated successfully at: {args.output}")
    except Exception as e:
        print(f"Error generating header: {str(e)}")
        exit(1)